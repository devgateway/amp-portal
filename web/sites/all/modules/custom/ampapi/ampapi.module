<?php
/**
 * @file
 * Provides an EFQ handler pointing to the AMP API.
 */

/**
 * Executes an EntityFieldQuery onto an AMP API endpoint.
 *
 * @see EntityFieldQuery::executeCallback()
 *
 * @param EntityFieldQuery $query
 *
 * @return array
 *
 * @throws ampAPIEntityQueryHelperException
 */
function ampapi_execute_query(EntityFieldQuery $query) {
  if (empty($query->entityConditions['entity_type']['value'])) {
    throw new ampAPIEntityQueryHelperException(t('An entity type must be specified.'));
  }
  $entity_type = $query->entityConditions['entity_type']['value'];

  $api_query_helper = new ampAPIEntityQueryHelper($entity_type);
  return $api_query_helper->executeQuery($query);
}

/**
 *  Implements hook_ctools_plugin_type().
 */
function ampapi_ctools_plugin_type() {
  $plugins['mapper'] = array(
    'cache' => TRUE,
  );

  return $plugins;
}

/**
 * Fetch metadata on a specific mapper plugin.
 *
 * @param $mapper_name
 *   Name of a mapper plugin.
 *
 * @return
 *   An array with information about the requested activity filter.
 */
function ampapi_get_mapper($mapper_name) {
  ctools_include('context');
  ctools_include('plugins');
  return ctools_get_plugins('ampapi', 'mapper', $mapper_name);
}

/**
 * Fetch metadata for all mapper plugins.
 *
 * @return
 *   An array of arrays with information about all available activity filters.
 */
function ampapi_get_mappers() {
  ctools_include('context');
  ctools_include('plugins');
  return ctools_get_plugins('ampapi', 'mapper');
}

/**
 * Fetch mapper plugin metadata for a specific property.
 *
 * @param $property_name
 *   Name of an property.
 *
 * @return
 *   An array with information about the requested activity filter.
 */
function ampapi_get_mapper_by_property_name($property_name) {
  $mapping = &drupal_static(__FUNCTION__, array());
  if (isset($mapping[$property_name])) {
    return $mapping[$property_name];
  }

  if ($property_name == 'entity_id') {
    $property_name = 'id';
  }

  $mappers = ampapi_get_mappers();
  foreach ($mappers as $key => $plugin) {
    if (empty($plugin['property name'])) {
      continue;
    }

    if ($plugin['property name'] == $property_name) {
      $mapping[$property_name] = $plugin;
      return $plugin;
    }
  }

  return NULL;
}

/**
 * Returns a list information about AMP document fields.
 * @param string $entity_type
 * @return array
 */
function ampapi_get_schema_info($entity_type) {
  $info = entity_get_info($entity_type);
  if (in_array('ampAPISchemaInterface', class_implements($info['controller class']))) {
    // Manually call static public method.
    return call_user_func_array(array($info['controller class'], 'schemaInfo'), array());
  }

  return array();
}

/**
 * Access callback for custom AMP entities.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param $entity_type
 *   The entity type of the entity to check for.
 * @param Entity $entity
 *   Optionally an entity to check access for. If no entity is given, it will be
 *   determined whether access is allowed for all entities of the given type.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the global user.
 *
 * @return boolean
 *   Whether access is allowed or not. If the entity type does not specify any
 *   access information, NULL is returned.
 */
function ampapi_entity_access($op, $entity = NULL, $account = NULL, $entity_type) {
  $rights = &drupal_static(__FUNCTION__, array());

  $operations = array('administer', 'access overview', 'create', 'view', 'edit', 'delete');
  if (!in_array($op, $operations, TRUE)) {
    // If the $op was not one of the supported ones, we return access denied.
    return FALSE;
  }

  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  $cid = is_object($entity) ? $entity_type . ':' . $entity->identifier() : FALSE;

  // If we've already checked access for this node, user and op, return from cache.
  if ($cid && isset($rights[$account->uid][$cid][$op])) {
    return $rights[$account->uid][$cid][$op];
  }

  if ($op == 'view') {
    if (empty($cid)) {
      return FALSE;
    }

    $allow = FALSE;
    $property_info = entity_get_property_info($entity_type);

    if (!array_key_exists('status', $property_info['properties'])) {
      // Always allow access to entities that don't have a status field.
      $allow = TRUE;
    }
    else if (user_access("$entity_type entity administer") || user_access("$entity_type entity access overview")) {
      $allow = TRUE;
    }
    else {
      /** @noinspection PhpUndefinedFieldInspection */
      $entity_status = $entity->status;
      if ($entity_status && user_access("$entity_type entity $op")) {
        $allow = TRUE;
      }
    }

    $rights[$account->uid][$cid][$op] = $allow;
    return $allow;
  }

  if (user_access("$entity_type entity $op")) {
    if ($cid) {
      $rights[$account->uid][$cid][$op] = TRUE;
    }
    return TRUE;
  }

  if ($cid) {
    $rights[$account->uid][$cid][$op] = FALSE;
  }
  return FALSE;
}
